// package main

// import (
// 	"encoding/json"
// 	"fmt"
// 	"net/http"
// )

// type ChatRequest struct {
// 	Message string `json:"message"`
// }
// type ChatResponse struct {
// 	Reply string `json:"reply"`
// }

// func chatHandler(w http.ResponseWriter, r *http.Request) {
// 	// ✅ Allow cross-origin requests (important for decoupled frontend)
// 	w.Header().Set("Access-Control-Allow-Origin", "*")
// 	w.Header().Set("Access-Control-Allow-Methods", "POST, OPTIONS")
// 	w.Header().Set("Access-Control-Allow-Headers", "Content-Type")
// 	w.Header().Set("Content-Type", "application/json")

// 	if r.Method == http.MethodOptions {
// 		return // handle CORS preflight
// 	}

// 	if r.Method != http.MethodPost {
// 		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
// 		return
// 	}

// 	var req ChatRequest
// 	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
// 		http.Error(w, err.Error(), http.StatusBadRequest)
// 		return
// 	}

// 	// Mock Johnny Bravo reply
// 	reply := fmt.Sprintf("Whoa mama! You said: %s", req.Message)

// 	json.NewEncoder(w).Encode(ChatResponse{Reply: reply})
// }

// func main() {
// 	http.HandleFunc("/chat", chatHandler)
// 	fmt.Println("✅ Go API running at http://localhost:8080")
// 	http.ListenAndServe(":8080", nil)
// }

// package main

// import (
// 	"context"
// 	"fmt"

// 	"github.com/openai/openai-go/v3"
// 	"github.com/openai/openai-go/v3/option"
// )

// func main() {
// 	client := openai.NewClient(
// 		option.WithAPIKey("My API Key"), // or set OPENAI_API_KEY in your env
// 	)

// 	resp, err := client.Responses.New(context.TODO(), openai.ResponseNewParams{
// 		Model: openai.F("gpt-5"),
// 		Input: openai.F("Say this is a test"),
// 	})
// 	if err != nil {
// 		panic(err.Error())
// 	}

// 	fmt.Println(resp.OutputText)
// }

// package main

// import (
// 	"bytes"
// 	"encoding/json"
// 	"fmt"
// 	"io"
// 	"log"
// 	"net/http"
// 	"os"
// )

// // Incoming request from your frontend
// type ChatRequest struct {
// 	Message string `json:"message"`
// }

// // Outgoing response to your frontend
// type ChatResponse struct {
// 	Reply string `json:"reply"`
// }

// // Groq API response (non-streaming)
// type groqResponse struct {
// 	Choices []struct {
// 		Message struct {
// 			Content string `json:"content"`
// 		} `json:"message"`
// 	} `json:"choices"`
// }

// func main() {
// 	apiKey := os.Getenv("GROQ_API_KEY")
// 	if apiKey == "" {
// 		log.Fatal("GROQ_API_KEY not set in environment")
// 	}

// 	http.HandleFunc("/chat", func(w http.ResponseWriter, r *http.Request) {
// 		// CORS for your decoupled frontend
// 		w.Header().Set("Access-Control-Allow-Origin", "*")
// 		w.Header().Set("Access-Control-Allow-Methods", "POST, OPTIONS")
// 		w.Header().Set("Access-Control-Allow-Headers", "Content-Type")
// 		w.Header().Set("Content-Type", "application/json")

// 		if r.Method == http.MethodOptions {
// 			return
// 		}
// 		if r.Method != http.MethodPost {
// 			http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
// 			return
// 		}

// 		var reqBody ChatRequest
// 		if err := json.NewDecoder(r.Body).Decode(&reqBody); err != nil {
// 			http.Error(w, err.Error(), http.StatusBadRequest)
// 			return
// 		}

// 		reply, err := callGroq(apiKey, reqBody.Message)
// 		if err != nil {
// 			log.Println("groq error:", err)
// 			http.Error(w, "AI error", http.StatusInternalServerError)
// 			return
// 		}

// 		json.NewEncoder(w).Encode(ChatResponse{Reply: reply})
// 	})

// 	fmt.Println("✅ Go API running at http://localhost:8080")
// 	log.Fatal(http.ListenAndServe(":8080", nil))
// }

// func callGroq(apiKey, userMsg string) (string, error) {
// 	// Basic single-turn chat: system → user
// 	body := map[string]any{
// 		"model": "llama-3.1-8b-instant",
// 		"messages": []map[string]string{
// 			{"role": "system", "content": "You are Mitzy, a character in a game. Be flirty, overconfident, and funny."},
// 			{"role": "user", "content": userMsg},
// 		},
// 		"temperature": 1.0,
// 		"top_p":       1.0,
// 		"stream":      false, // simpler for HTTP API
// 	}

// 	payload, err := json.Marshal(body)
// 	if err != nil {
// 		return "", fmt.Errorf("marshal body: %w", err)
// 	}

// 	req, err := http.NewRequest(
// 		http.MethodPost,
// 		"https://api.groq.com/openai/v1/chat/completions",
// 		bytes.NewReader(payload),
// 	)
// 	if err != nil {
// 		return "", fmt.Errorf("new request: %w", err)
// 	}

// 	req.Header.Set("Content-Type", "application/json")
// 	req.Header.Set("Authorization", "Bearer "+apiKey)

// 	resp, err := http.DefaultClient.Do(req)
// 	if err != nil {
// 		return "", fmt.Errorf("request error: %w", err)
// 	}
// 	defer resp.Body.Close()

// 	if resp.StatusCode != http.StatusOK {
// 		b, _ := io.ReadAll(resp.Body)
// 		return "", fmt.Errorf("bad status %d: %s", resp.StatusCode, string(b))
// 	}

// 	var groqResp groqResponse
// 	if err := json.NewDecoder(resp.Body).Decode(&groqResp); err != nil {
// 		return "", fmt.Errorf("decode response: %w", err)
// 	}

// 	if len(groqResp.Choices) == 0 {
// 		return "", fmt.Errorf("no choices in response")
// 	}

// 	return groqResp.Choices[0].Message.Content, nil
// }